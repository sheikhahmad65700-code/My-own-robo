<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Premium 3D Particle System - Fully Working</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  video { display:none; }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js';

// --- THREE.JS SETUP ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 35;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// Lights
scene.add(new THREE.AmbientLight(0xffffff,0.2));
const pointLight = new THREE.PointLight(0xffffff,0.5);
pointLight.position.set(0,0,50);
scene.add(pointLight);

// --- PARTICLES ---
const particleCount = 2500;
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(particleCount*3);
const targetPositions = new Float32Array(particleCount*3);

for(let i=0;i<particleCount*3;i++){
  positions[i] = (Math.random()-0.5)*6;
  targetPositions[i] = positions[i];
}
geometry.setAttribute('position', new THREE.BufferAttribute(positions,3));

const material = new THREE.PointsMaterial({
  size:0.05,
  color:0xff3399,
  transparent:true,
  opacity:0.8
});
const particles = new THREE.Points(geometry,material);
scene.add(particles);

// --- TEMPLATE FUNCTIONS ---
function generateSphereGap(target){
  const gapChance = 0.2;
  for(let i=0;i<particleCount;i++){
    const theta = Math.random()*Math.PI*2;
    const phi = Math.acos(2*Math.random()-1);
    const r = 5;
    if(Math.random()<gapChance){
      target[i*3]=target[i*3+1]=target[i*3+2]=0;
    } else {
      target[i*3] = r*Math.sin(phi)*Math.cos(theta);
      target[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
      target[i*3+2] = r*Math.cos(phi);
    }
  }
}

function generateHeart(target){
  for(let i=0;i<particleCount;i++){
    const t=Math.random()*Math.PI*2;
    const s=Math.random();
    target[i*3]=6*Math.pow(Math.sin(t),3)*s;
    target[i*3+1]=(5*Math.cos(t)-2*Math.cos(2*t)-1*Math.cos(3*t)-0.5*Math.cos(4*t))*s;
    target[i*3+2]=(Math.random()-0.5)*0.5;
  }
}

function generateSpiral(target){
  for(let i=0;i<particleCount;i++){
    const t=i*0.03;
    target[i*3]=t*Math.cos(t/5);
    target[i*3+1]=t*Math.sin(t/5);
    target[i*3+2]=(Math.random()-0.5)*1;
  }
}

function generateFireworks(target){
  for(let i=0;i<particleCount;i++){
    const r=Math.random()*5;
    const theta=Math.random()*Math.PI*2;
    const phi=Math.random()*Math.PI;
    target[i*3]=r*Math.sin(phi)*Math.cos(theta);
    target[i*3+1]=r*Math.sin(phi)*Math.sin(theta);
    target[i*3+2]=r*Math.cos(phi);
  }
}

function generateFlower(target){
  for(let i=0;i<particleCount;i++){
    const theta=Math.random()*Math.PI*2;
    const r=Math.sin(6*theta)*2.5;
    target[i*3]=r*Math.cos(theta);
    target[i*3+1]=r*Math.sin(theta);
    target[i*3+2]=(Math.random()-0.5)*0.5;
  }
}

function generateSaturn(target){
  for(let i=0;i<particleCount;i++){
    const theta=Math.random()*Math.PI*2;
    const r=4+(Math.random()-0.5)*1;
    target[i*3]=r*Math.cos(theta);
    target[i*3+1]=(Math.random()-0.5)*0.8;
    target[i*3+2]=r*Math.sin(theta);
  }
}

function generateCube(target){
  for(let i=0;i<particleCount;i++){
    target[i*3]=(Math.random()-0.5)*6;
    target[i*3+1]=(Math.random()-0.5)*6;
    target[i*3+2]=(Math.random()-0.5)*6;
  }
}

function generateCone(target){
  for(let i=0;i<particleCount;i++){
    const h=Math.random()*6;
    const r=(6-h)*Math.random();
    const theta=Math.random()*Math.PI*2;
    target[i*3]=r*Math.cos(theta);
    target[i*3+1]=h-3;
    target[i*3+2]=r*Math.sin(theta);
  }
}

function generateStar(target){
  for(let i=0;i<particleCount;i++){
    const theta=Math.random()*Math.PI*2;
    const r=2+Math.random()*3;
    const phi=Math.random()*Math.PI;
    target[i*3]=r*Math.sin(phi)*Math.cos(theta);
    target[i*3+1]=r*Math.sin(phi)*Math.sin(theta);
    target[i*3+2]=r*Math.cos(phi);
  }
}

function generateTorus(target){
  for(let i=0;i<particleCount;i++){
    const theta=Math.random()*Math.PI*2;
    const phi=Math.random()*Math.PI*2;
    const R=3, r=1;
    target[i*3]=(R+r*Math.cos(phi))*Math.cos(theta);
    target[i*3+1]=r*Math.sin(phi);
    target[i*3+2]=(R+r*Math.cos(phi))*Math.sin(theta);
  }
}

// Additional templates: Diamond, Wave, Pyramid, DoubleHeart, Swirl
function generateDiamond(target){
  for(let i=0;i<particleCount;i++){
    const x=(Math.random()-0.5)*6;
    const y=(Math.random()-0.5)*6;
    const z=Math.abs(x)+Math.abs(y);
    target[i*3]=x; target[i*3+1]=y; target[i*3+2]=z-3;
  }
}
function generateWave(target){
  for(let i=0;i<particleCount;i++){
    const x=(Math.random()-0.5)*6;
    const y=Math.sin(x*2*Math.PI)*2;
    const z=(Math.random()-0.5)*6;
    target[i*3]=x; target[i*3+1]=y; target[i*3+2]=z;
  }
}
function generatePyramid(target){
  for(let i=0;i<particleCount;i++){
    const h=Math.random()*6;
    const size=(6-h)*Math.random();
    const angle=Math.random()*Math.PI*2;
    target[i*3]=size*Math.cos(angle);
    target[i*3+1]=h-3;
    target[i*3+2]=size*Math.sin(angle);
  }
}
function generateDoubleHeart(target){
  for(let i=0;i<particleCount;i++){
    const t=Math.random()*Math.PI*2;
    const s=Math.random();
    const shift = (i%2===0?4:-4);
    target[i*3]=6*Math.pow(Math.sin(t),3)*s+shift;
    target[i*3+1]=(5*Math.cos(t)-2*Math.cos(2*t)-1*Math.cos(3*t)-0.5*Math.cos(4*t))*s;
    target[i*3+2]=(Math.random()-0.5)*0.5;
  }
}
function generateSwirl(target){
  for(let i=0;i<particleCount;i++){
    const t=i*0.05;
    target[i*3]=t*Math.cos(t);
    target[i*3+1]=t*Math.sin(t)/2;
    target[i*3+2]=(Math.random()-0.5)*1;
  }
}

// --- HAND TRACKING ---
const videoElement=document.createElement('video');
document.body.appendChild(videoElement);

const hands=new Hands({
  locateFile:file=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});
hands.setOptions({
  maxNumHands:1,
  modelComplexity:1,
  minDetectionConfidence:0.7,
  minTrackingConfidence:0.7
});

let currentGesture=null;
let rotationX=0, rotationY=0, rotationZ=0;
let appliedRotX=0, appliedRotY=0, appliedRotZ=0;

// Initialize default template
generateSphereGap(targetPositions);

hands.onResults(results=>{
  if(results.multiHandLandmarks.length>0){
    const lm = results.multiHandLandmarks[0];

    // Particle size & color
    const dx = lm[4].x - lm[8].x;
    const dy = lm[4].y - lm[8].y;
    const dist = Math.sqrt(dx*dx+dy*dy);
    particles.material.size=THREE.MathUtils.clamp(dist*15,0.03,0.3);
    const hue = lm[0].x;
    const col = new THREE.Color();
    col.setHSL(hue,0.9,0.6);
    particles.material.color=col;

    // Reliable gesture detection
    const fingers = [
      lm[8].y<lm[6].y,  // index
      lm[12].y<lm[10].y, // middle
      lm[16].y<lm[14].y, // ring
      lm[20].y<lm[18].y, // pinky
      lm[4].y<lm[3].y    // thumb
    ];

    let gesture='sphere'; // default
    if(fingers.every(f=>!f)) gesture='fist';
    else if(fingers.every(f=>f)) gesture='openpalm';
    else if(fingers[0]&&fingers[1]&&!fingers[2]&&!fingers[3]) gesture='peace';
    else if(fingers[4]&&!fingers[0]&&!fingers[1]&&!fingers[2]&&!fingers[3]) gesture='thumbup';
    else if(fingers[0]&&!fingers[1]&&!fingers[2]&&!fingers[3]&&!fingers[4]) gesture='indexpoint';

    if(gesture!==currentGesture){
      currentGesture=gesture;
      switch(gesture){
        case 'fist': generateHeart(targetPositions); break;
        case 'openpalm': generateSphereGap(targetPositions); break;
        case 'peace': generateSpiral(targetPositions); break;
        case 'thumbup': generateFlower(targetPositions); break;
        case 'indexpoint': generateFireworks(targetPositions); break;
        default: generateSphereGap(targetPositions);
      }
    }

    // Hand rotation
    rotationX=(lm[9].y-lm[0].y)*0.3;
    rotationY=(lm[9].x-lm[0].x)*0.3;
    rotationZ=(lm[8].x-lm[20].x)*0.3;
  } else rotationX=rotationY=rotationZ=0;
});

new Camera(videoElement,{
  onFrame: async()=>{await hands.send({image:videoElement});},
  width:640,
  height:480
}).start();

// --- ANIMATION LOOP ---
function animate(){
  requestAnimationFrame(animate);

  const pos=geometry.attributes.position.array;
  for(let i=0;i<pos.length;i++){
    pos[i]+=(targetPositions[i]-pos[i])*0.08 + (Math.random()-0.5)*0.0005;
  }
  geometry.attributes.position.needsUpdate=true;

  // Smooth rotation
  appliedRotX+=(rotationX-appliedRotX)*0.05;
  appliedRotY+=(rotationY-appliedRotY)*0.05;
  appliedRotZ+=(rotationZ-appliedRotZ)*0.05;

  particles.rotation.x=appliedRotX;
  particles.rotation.y=appliedRotY;
  particles.rotation.z=appliedRotZ;

  renderer.render(scene,camera);
}
animate();

</script>
</body>
</html>
